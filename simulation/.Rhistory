results=data.frame(matrix(ncol = 7, nrow = M))
colnames(results)=c("trueATE", "BayesATE", "BayesCI1", "BayesCI2", "FreqATE", "FreqCI1", "FreqCI2")
for(m in 1:M){
outcome=continuousdata[[m]][["outcome"]]
treatment=continuousdata[[m]][["treatment"]]
covardataset=continuousdata[[m]][["covariates"]]
trueATE=continuousdata[[m]][["benefitATE"]]
cat(m, "\n")
#cat("true ATE: ", trueATE, "\n")
############ BPSA ##############
K=800 # K=500 cannot converge
BPSA.est.PS = PS.design(outcome,treatment,covardataset,bayes=TRUE,K=K)
stratATE = rep(NA,K)
stratSE = rep(NA,K)
for(k in 1:K){
strat = PS.analysis(BPSA.est.PS[,k],treatment,outcome,covardataset,bpsa=2,S=600) # S=400 cannot converge
stratATE[k] = strat$ATE
stratSE[k] = strat[["Average SE"]]
}
BPSA.ATE = mean(stratATE,na.rm=TRUE)
CI=bayes.output(stratATE,stratSE)
coverage_BPSA[m]=between(trueATE,CI[1],CI[2])
results[m,1:4]=data.frame(trueATE,BPSA.ATE,CI[1],CI[2])
############ PSA ##############
PSA.est.PS = PS.design(outcome,treatment,covardataset,bayes=FALSE)
strat = PS.analysis(PSA.est.PS,treatment,outcome,covardataset,bpsa = 1)
PSA.ate = mean(strat$ATE)
PSA.se = strat[["Average SE"]]
CI=freq.output(PSA.ate,PSA.se)
coverage_PSA[m]=between(trueATE,CI[1],CI[2])
results[m,5:7]=data.frame(PSA.ate,CI[1],CI[2])
#cat("\n")
}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, comment = NA)
set.seed(1234)
# Number of samples
n_samples <- 1000
# 1. Generate four independent standard normal confounders
C1 <- rnorm(n_samples)
C2 <- rnorm(n_samples)
C3 <- rnorm(n_samples)
C4 <- rnorm(n_samples)
# 2. Generate the true treatment assignment mechanism
P_X_given_C <- -1 + log(1.75) * (C1 + C2 + C3 + C4)
# Assuming a logistic function to get probability
prob_X <- 1 / (1 + exp(-P_X_given_C))
expit <- function(x){ exp(x)/(1+exp(x)) }
prob_X1 <- expit(prob_X)
X <- as.integer(runif(n_samples) < prob_X)
# 3. Generate the true outcome mechanism
epsilon <- rnorm(n_samples, 0, 6)
Y <- 120 + 6 * X + 3 * (C1 + C2 + C3 + C4) + epsilon
# Combine the data into a dataframe for further analysis
data <- data.frame(C1, C2, C3, C4, X, Y)
head(data)
prob_X1 <- expit(P_X_given_C)
library(dplyr)
library(SuperLearner)
library(tmle)
library(dbarts)
library(boot)
library(mvtnorm)
library(readr)
library(sandwich)
library(tibble)
library(tidyr)
set.seed(1234)
# Number of samples
n_samples <- 1000
# 1. Generate four independent standard normal confounders
C1 <- rnorm(n_samples)
C2 <- rnorm(n_samples)
C3 <- rnorm(n_samples)
C4 <- rnorm(n_samples)
# 2. Generate the true treatment assignment mechanism
P_X_given_C <- -1 + log(1.75) * (C1 + C2 + C3 + C4)
# Assuming a logistic function to get probability
expit <- function(x){ exp(x)/(1+exp(x)) }
prob_X <- expit(P_X_given_C)
X <- as.integer(runif(n_samples) < prob_X)
# 3. Generate the true outcome mechanism
epsilon <- rnorm(n_samples, 0, 6)
Y <- 120 + 6 * X + 3 * (C1 + C2 + C3 + C4) + epsilon
# Combine the data into a dataframe for further analysis
data <- data.frame(C1, C2, C3, C4, X, Y)
head(data)
library(dplyr)
library(SuperLearner)
library(tmle)
library(dbarts)
library(boot)
library(mvtnorm)
library(readr)
library(sandwich)
library(tibble)
library(tidyr)
set.seed(1234)
# Number of samples
n_samples <- 1000
# 1. Generate four independent standard normal confounders
C1 <- rnorm(n_samples)
C2 <- rnorm(n_samples)
C3 <- rnorm(n_samples)
C4 <- rnorm(n_samples)
# 2. Generate the true treatment assignment mechanism
P_X_given_C <- -1 + log(1.75) * (C1 + C2 + C3 + C4)
# Assuming a logistic function to get probability
expit <- function(x){ exp(x)/(1+exp(x)) }
prob_X <- expit(P_X_given_C)
X <- as.integer(runif(n_samples) < prob_X)
# 3. Generate the true outcome mechanism
epsilon <- rnorm(n_samples, 0, 6)
Y <- 120 + 6 * X + 3 * (C1 + C2 + C3 + C4) + epsilon
# Combine the data into a dataframe for further analysis
data <- data.frame(C1, C2, C3, C4, X, Y)
head(data)
Z1 <- exp(C1/2)
Z2 <- C2/(1 + exp(C1)) + 10
Z3 <- (C1*C3/25 + 0.6)^3
Z4 <- (C2 + C4 + 20)^2
source("risk.data.generation.R")
source("risk.designfunction.R")
source("risk.analysisfunction.R")
rubinse = function(ates,sigmas){
K = length(ates)
sqrt(mean(sigmas^2,na.rm=TRUE) + var(ates,na.rm=TRUE))
}
bayes.output = function(stratATE,stratSE){
BPSA.ATE = mean(stratATE,na.rm=TRUE)
BPSA.lower = BPSA.ATE - 1.96*rubinse(stratATE,stratSE)
BPSA.upper = BPSA.ATE + 1.96*rubinse(stratATE,stratSE)
#cat("BPSA: ",round(BPSA.ATE,3), "(", round(BPSA.lower,3), ",", round(BPSA.upper,3), ")\n")
return(c(BPSA.lower,BPSA.upper))
}
freq.output = function(PSA.ate,PSA.se){
PSA.lower = PSA.ate - 1.96*PSA.se
PSA.upper = PSA.ate + 1.96*PSA.se
#cat("PSA: ",round(PSA.ate,3), "(", round(PSA.lower,3), ",", round(PSA.upper,3), ")\n")
return(c(PSA.lower,PSA.upper))
}
library(dplyr)
coverage_BPSA=rep(NA,M)
coverage_PSA=rep(NA,M)
results=data.frame(matrix(ncol = 7, nrow = M))
colnames(results)=c("trueATE", "BayesATE", "BayesCI1", "BayesCI2", "FreqATE", "FreqCI1", "FreqCI2")
for(m in 1:M){
outcome=continuousdata[[m]][["outcome"]]
treatment=continuousdata[[m]][["treatment"]]
covardataset=continuousdata[[m]][["covariates"]]
trueATE=continuousdata[[m]][["benefitATE"]]
cat(m, "\n")
#cat("true ATE: ", trueATE, "\n")
############ BPSA ##############
K=800 # K=500 cannot converge
BPSA.est.PS = PS.design(outcome,treatment,covardataset,bayes=TRUE,K=K)
stratATE = rep(NA,K)
stratSE = rep(NA,K)
for(k in 1:K){
strat = PS.analysis(BPSA.est.PS[,k],treatment,outcome,covardataset,bpsa=2,S=600) # S=400 cannot converge
stratATE[k] = strat$ATE
stratSE[k] = strat[["Average SE"]]
}
BPSA.ATE = mean(stratATE,na.rm=TRUE)
CI=bayes.output(stratATE,stratSE)
coverage_BPSA[m]=between(trueATE,CI[1],CI[2])
results[m,1:4]=data.frame(trueATE,BPSA.ATE,CI[1],CI[2])
############ PSA ##############
PSA.est.PS = PS.design(outcome,treatment,covardataset,bayes=FALSE)
strat = PS.analysis(PSA.est.PS,treatment,outcome,covardataset,bpsa = 1)
PSA.ate = mean(strat$ATE)
PSA.se = strat[["Average SE"]]
CI=freq.output(PSA.ate,PSA.se)
coverage_PSA[m]=between(trueATE,CI[1],CI[2])
results[m,5:7]=data.frame(PSA.ate,CI[1],CI[2])
#cat("\n")
}
mean(coverage_BPSA,na.rm = TRUE)
mean(coverage_PSA,na.rm = TRUE)
View(results)
View(results)
results1 =results[1:200,]
View(results1)
mean(abs(results1$trueATE-results1$BayesATE))
mean(abs(results1$trueATE-results1$FreqATE))
View(results1)
rm(results1)
save.image("C:/Users/ad6557/Desktop/Rotation/Hyung Park/Two-stage-Bayesian-ATE/simulation/m200_confound_stage2.RData")
source("risk.data.generation.R")
source("risk.designfunction.R")
source("risk.analysisfunction.R")
rubinse = function(ates,sigmas){
K = length(ates)
sqrt(mean(sigmas^2,na.rm=TRUE) + var(ates,na.rm=TRUE))
}
bayes.output = function(stratATE,stratSE){
BPSA.ATE = mean(stratATE,na.rm=TRUE)
BPSA.SE = rubinse(stratATE,stratSE)
BPSA.lower = BPSA.ATE - 1.96*BPSA.SE
BPSA.upper = BPSA.ATE + 1.96*BPSA.SE
#cat("BPSA: ",round(BPSA.ATE,3), "(", round(BPSA.lower,3), ",", round(BPSA.upper,3), ")\n")
return(c(BPSA.lower,BPSA.upper,BPSA.ATE,BPSA.SE))
}
freq.output = function(PSA.ate,PSA.se){
PSA.lower = PSA.ate - 1.96*PSA.se
PSA.upper = PSA.ate + 1.96*PSA.se
#cat("PSA: ",round(PSA.ate,3), "(", round(PSA.lower,3), ",", round(PSA.upper,3), ")\n")
return(c(PSA.lower,PSA.upper))
}
library(dplyr)
#coverage_BPSA=rep(NA,M)
#coverage_PSA=rep(NA,M)
results=data.frame(matrix(ncol = 7, nrow = M))
colnames(results)=c("trueATE",
"BayesATE", "BayesSE", "BayesCI1", "BayesCI2", "BPSAcoverage",
"FreqATE", "FreqSE", "FreqCI1", "FreqCI2", "PSAcoverage")
#coverage_BPSA=rep(NA,M)
#coverage_PSA=rep(NA,M)
results=data.frame(matrix(ncol = 11, nrow = M))
colnames(results)=c("trueATE",
"BayesATE", "BayesSE", "BayesCI1", "BayesCI2", "BPSAcoverage",
"FreqATE", "FreqSE", "FreqCI1", "FreqCI2", "PSAcoverage")
for(m in 1:M){
outcome=continuousdata[[m]][["outcome"]]
treatment=continuousdata[[m]][["treatment"]]
covardataset=continuousdata[[m]][["covariates"]]
trueATE=continuousdata[[m]][["benefitATE"]]
cat(m, "\n")
#cat("true ATE: ", trueATE, "\n")
############ BPSA ##############
K=50
BPSA.est.PS = PS.design(outcome,treatment,covardataset,bayes=TRUE,K=K)
stratATE = rep(NA,K)
stratSE = rep(NA,K)
for(k in 1:K){
strat = PS.analysis(BPSA.est.PS[,k],treatment,outcome,covardataset,bpsa=2,S=1000)
stratATE[k] = strat$ATE
stratSE[k] = strat[["Average SE"]]
}
CI=bayes.output(stratATE,stratSE)
coverage_BPSA=between(trueATE,CI[1],CI[2])
results[m,1:6]=data.frame(trueATE,CI[3],CI[4],CI[1],CI[2],coverage_BPSA)
############ PSA ##############
PSA.est.PS = PS.design(outcome,treatment,covardataset,bayes=FALSE)
strat = PS.analysis(PSA.est.PS,treatment,outcome,covardataset,bpsa = 1)
PSA.ate = mean(strat$ATE)
PSA.se = strat[["Average SE"]]
CI=freq.output(PSA.ate,PSA.se)
coverage_PSA=between(trueATE,CI[1],CI[2])
results[m,7:11]=data.frame(PSA.ate,PSA.se,CI[1],CI[2],coverage_PSA)
#cat("\n")
}
View(results)
save(file = M+"_adjusted_stage2.RData")
save(file = paste0(M,"_adjusted_stage2.RData"))
load("C:/Users/ad6557/Desktop/Rotation/Hyung Park/Two-stage-Bayesian-ATE/simulation/10_adjusted_stage2.RData")
load("C:/Users/ad6557/Desktop/Rotation/Hyung Park/Two-stage-Bayesian-ATE/simulation/10_adjusted_stage2.RData")
source("risk.data.generation.R")
source("risk.designfunction.R")
source("risk.analysisfunction.R")
rubinse = function(ates,sigmas){
K = length(ates)
sqrt(mean(sigmas^2,na.rm=TRUE) + var(ates,na.rm=TRUE))
}
bayes.output = function(stratATE,stratSE){
BPSA.ATE = mean(stratATE,na.rm=TRUE)
BPSA.SE = rubinse(stratATE,stratSE)
BPSA.lower = BPSA.ATE - 1.96*BPSA.SE
BPSA.upper = BPSA.ATE + 1.96*BPSA.SE
#cat("BPSA: ",round(BPSA.ATE,3), "(", round(BPSA.lower,3), ",", round(BPSA.upper,3), ")\n")
return(c(BPSA.lower,BPSA.upper,BPSA.ATE,BPSA.SE))
}
freq.output = function(PSA.ate,PSA.se){
PSA.lower = PSA.ate - 1.96*PSA.se
PSA.upper = PSA.ate + 1.96*PSA.se
#cat("PSA: ",round(PSA.ate,3), "(", round(PSA.lower,3), ",", round(PSA.upper,3), ")\n")
return(c(PSA.lower,PSA.upper))
}
library(dplyr)
#coverage_BPSA=rep(NA,M)
#coverage_PSA=rep(NA,M)
results=data.frame(matrix(ncol = 11, nrow = M))
colnames(results)=c("trueATE",
"BayesATE", "BayesSE", "BayesCI1", "BayesCI2", "BPSAcoverage",
"FreqATE", "FreqSE", "FreqCI1", "FreqCI2", "PSAcoverage")
for(m in 1:M){
outcome=continuousdata[[m]][["outcome"]]
treatment=continuousdata[[m]][["treatment"]]
covardataset=continuousdata[[m]][["covariates"]]
trueATE=continuousdata[[m]][["benefitATE"]]
cat(m, "\n")
#cat("true ATE: ", trueATE, "\n")
############ BPSA ##############
K=50
BPSA.est.PS = PS.design(outcome,treatment,covardataset,bayes=TRUE,K=K)
stratATE = rep(NA,K)
stratSE = rep(NA,K)
for(k in 1:K){
strat = PS.analysis(BPSA.est.PS[,k],treatment,outcome,covardataset,bpsa=2,S=1000)
stratATE[k] = strat$ATE
stratSE[k] = strat[["Average SE"]]
}
CI=bayes.output(stratATE,stratSE)
coverage_BPSA=between(trueATE,CI[1],CI[2])
results[m,1:6]=data.frame(trueATE,CI[3],CI[4],CI[1],CI[2],coverage_BPSA)
############ PSA ##############
PSA.est.PS = PS.design(outcome,treatment,covardataset,bayes=FALSE)
strat = PS.analysis(PSA.est.PS,treatment,outcome,covardataset,bpsa = 1)
PSA.ate = mean(strat$ATE)
PSA.se = strat[["Average SE"]]
CI=freq.output(PSA.ate,PSA.se)
coverage_PSA=between(trueATE,CI[1],CI[2])
results[m,7:11]=data.frame(PSA.ate,PSA.se,CI[1],CI[2],coverage_PSA)
#cat("\n")
}
save.image(file = paste0(M,"_adjusted_stage2.RData"))
load("C:/Users/ad6557/Desktop/Rotation/Hyung Park/Two-stage-Bayesian-ATE/simulation/5_adjusted_stage2.RData")
View(results)
source("risk.data.generation.R")
source("risk.designfunction.R")
source("risk.analysisfunction.R")
rubinse = function(ates,sigmas){
K = length(ates)
sqrt(mean(sigmas^2,na.rm=TRUE) + var(ates,na.rm=TRUE))
}
bayes.output = function(stratATE,stratSE){
BPSA.ATE = mean(stratATE,na.rm=TRUE)
BPSA.SE = rubinse(stratATE,stratSE)
BPSA.lower = BPSA.ATE - 1.96*BPSA.SE
BPSA.upper = BPSA.ATE + 1.96*BPSA.SE
#cat("BPSA: ",round(BPSA.ATE,3), "(", round(BPSA.lower,3), ",", round(BPSA.upper,3), ")\n")
return(c(BPSA.lower,BPSA.upper,BPSA.ATE,BPSA.SE))
}
freq.output = function(PSA.ate,PSA.se){
PSA.lower = PSA.ate - 1.96*PSA.se
PSA.upper = PSA.ate + 1.96*PSA.se
#cat("PSA: ",round(PSA.ate,3), "(", round(PSA.lower,3), ",", round(PSA.upper,3), ")\n")
return(c(PSA.lower,PSA.upper))
}
library(dplyr)
#coverage_BPSA=rep(NA,M)
#coverage_PSA=rep(NA,M)
results=data.frame(matrix(ncol = 11, nrow = M))
colnames(results)=c("trueATE",
"BayesATE", "BayesSE", "BayesCI1", "BayesCI2", "BPSAcoverage",
"FreqATE", "FreqSE", "FreqCI1", "FreqCI2", "PSAcoverage")
for(m in 1:M){
outcome=continuousdata[[m]][["outcome"]]
treatment=continuousdata[[m]][["treatment"]]
covardataset=continuousdata[[m]][["covariates"]]
trueATE=continuousdata[[m]][["benefitATE"]]
cat(m, "\n")
#cat("true ATE: ", trueATE, "\n")
############ BPSA ##############
K=50
BPSA.est.PS = PS.design(outcome,treatment,covardataset,bayes=TRUE,K=K)
stratATE = rep(NA,K)
stratSE = rep(NA,K)
for(k in 1:K){
strat = PS.analysis(BPSA.est.PS[,k],treatment,outcome,covardataset,bpsa=2,S=1000)
stratATE[k] = strat$ATE
stratSE[k] = strat[["Average SE"]]
}
CI=bayes.output(stratATE,stratSE)
coverage_BPSA=between(trueATE,CI[1],CI[2])
results[m,1:6]=data.frame(trueATE,CI[3],CI[4],CI[1],CI[2],coverage_BPSA)
############ PSA ##############
PSA.est.PS = PS.design(outcome,treatment,covardataset,bayes=FALSE)
strat = PS.analysis(PSA.est.PS,treatment,outcome,covardataset,bpsa = 1)
PSA.ate = mean(strat$ATE)
PSA.se = strat[["Average SE"]]
CI=freq.output(PSA.ate,PSA.se)
coverage_PSA=between(trueATE,CI[1],CI[2])
results[m,7:11]=data.frame(PSA.ate,PSA.se,CI[1],CI[2],coverage_PSA)
#cat("\n")
}
save.image(file = paste0(M,"_adjusted_stage2.RData"))
View(results)
mean(results$BPSAcoverage)
mean(results$PSAcoverage)
mean(abs(results$trueATE-results$BayesATE))
mean(abs(results$trueATE-results$FreqATE))
load("C:/Users/ad6557/Desktop/Rotation/Hyung Park/Two-stage-Bayesian-ATE/simulation/M100p5_adjusted_s2.RData")
View(results)
mean(results$BPSAcoverage)
source("risk.data.generation.R")
source("risk.designfunction.R")
source("risk.analysisfunction.R")
rubinse = function(ates,sigmas){
K = length(ates)
sqrt(mean(sigmas^2,na.rm=TRUE) + var(ates,na.rm=TRUE))
}
bayes.output = function(stratATE,stratSE){
BPSA.ATE = mean(stratATE,na.rm=TRUE)
BPSA.SE = rubinse(stratATE,stratSE)
BPSA.lower = BPSA.ATE - 1.96*BPSA.SE
BPSA.upper = BPSA.ATE + 1.96*BPSA.SE
#cat("BPSA: ",round(BPSA.ATE,3), "(", round(BPSA.lower,3), ",", round(BPSA.upper,3), ")\n")
return(c(BPSA.lower,BPSA.upper,BPSA.ATE,BPSA.SE))
}
freq.output = function(PSA.ate,PSA.se){
PSA.lower = PSA.ate - 1.96*PSA.se
PSA.upper = PSA.ate + 1.96*PSA.se
#cat("PSA: ",round(PSA.ate,3), "(", round(PSA.lower,3), ",", round(PSA.upper,3), ")\n")
return(c(PSA.lower,PSA.upper))
}
library(dplyr)
#coverage_BPSA=rep(NA,M)
#coverage_PSA=rep(NA,M)
results=data.frame(matrix(ncol = 11, nrow = M))
colnames(results)=c("trueATE",
"BayesATE", "BayesSE", "BayesCI1", "BayesCI2", "BPSAcoverage",
"FreqATE", "FreqSE", "FreqCI1", "FreqCI2", "PSAcoverage")
for(m in 1:M){
outcome=continuousdata[[m]][["outcome"]]
treatment=continuousdata[[m]][["treatment"]]
covardataset=continuousdata[[m]][["covariates"]]
trueATE=continuousdata[[m]][["benefitATE"]]
cat(m, "\n")
#cat("true ATE: ", trueATE, "\n")
############ BPSA ##############
K=50
BPSA.est.PS = PS.design(outcome,treatment,covardataset,bayes=TRUE,K=K)
stratATE = rep(NA,K)
stratSE = rep(NA,K)
for(k in 1:K){
strat = PS.analysis(BPSA.est.PS[,k],treatment,outcome,covardataset,bpsa=2,S=1000)
stratATE[k] = strat$ATE
stratSE[k] = strat[["Average SE"]]
}
CI=bayes.output(stratATE,stratSE)
coverage_BPSA=between(trueATE,CI[1],CI[2])
results[m,1:6]=data.frame(trueATE,CI[3],CI[4],CI[1],CI[2],coverage_BPSA)
############ PSA ##############
PSA.est.PS = PS.design(outcome,treatment,covardataset,bayes=FALSE)
strat = PS.analysis(PSA.est.PS,treatment,outcome,covardataset,bpsa = 1)
PSA.ate = mean(strat$ATE)
PSA.se = strat[["Average SE"]]
CI=freq.output(PSA.ate,PSA.se)
coverage_PSA=between(trueATE,CI[1],CI[2])
results[m,7:11]=data.frame(PSA.ate,PSA.se,CI[1],CI[2],coverage_PSA)
#cat("\n")
}
mean(results$BPSAcoverage)
mean(results$PSAcoverage)
mean(abs(results$trueATE-results$BayesATE))
mean(abs(results$trueATE-results$FreqATE))
save.image(file = paste0("M",M,"p",p,"_adjusted_s2_flatprior.RData"))
source("risk.data.generation.R")
source("risk.designfunction.R")
source("risk.analysisfunction.R")
rubinse = function(ates,sigmas){
K = length(ates)
sqrt(mean(sigmas^2,na.rm=TRUE) + var(ates,na.rm=TRUE))
}
bayes.output = function(stratATE,stratSE){
BPSA.ATE = mean(stratATE,na.rm=TRUE)
BPSA.SE = rubinse(stratATE,stratSE)
BPSA.lower = BPSA.ATE - 1.96*BPSA.SE
BPSA.upper = BPSA.ATE + 1.96*BPSA.SE
#cat("BPSA: ",round(BPSA.ATE,3), "(", round(BPSA.lower,3), ",", round(BPSA.upper,3), ")\n")
return(c(BPSA.lower,BPSA.upper,BPSA.ATE,BPSA.SE))
}
freq.output = function(PSA.ate,PSA.se){
PSA.lower = PSA.ate - 1.96*PSA.se
PSA.upper = PSA.ate + 1.96*PSA.se
#cat("PSA: ",round(PSA.ate,3), "(", round(PSA.lower,3), ",", round(PSA.upper,3), ")\n")
return(c(PSA.lower,PSA.upper))
}
library(dplyr)
#coverage_BPSA=rep(NA,M)
#coverage_PSA=rep(NA,M)
results=data.frame(matrix(ncol = 11, nrow = M))
colnames(results)=c("trueATE",
"BayesATE", "BayesSE", "BayesCI1", "BayesCI2", "BPSAcoverage",
"FreqATE", "FreqSE", "FreqCI1", "FreqCI2", "PSAcoverage")
for(m in 1:M){
outcome=continuousdata[[m]][["outcome"]]
treatment=continuousdata[[m]][["treatment"]]
covardataset=continuousdata[[m]][["covariates"]]
trueATE=continuousdata[[m]][["benefitATE"]]
cat(m, "\n")
#cat("true ATE: ", trueATE, "\n")
############ BPSA ##############
K=50
BPSA.est.PS = PS.design(outcome,treatment,covardataset,bayes=TRUE,K=K)
stratATE = rep(NA,K)
stratSE = rep(NA,K)
for(k in 1:K){
strat = PS.analysis(BPSA.est.PS[,k],treatment,outcome,covardataset,bpsa=2,S=1000)
stratATE[k] = strat$ATE
stratSE[k] = strat[["Average SE"]]
}
CI=bayes.output(stratATE,stratSE)
coverage_BPSA=between(trueATE,CI[1],CI[2])
results[m,1:6]=data.frame(trueATE,CI[3],CI[4],CI[1],CI[2],coverage_BPSA)
############ PSA ##############
PSA.est.PS = PS.design(outcome,treatment,covardataset,bayes=FALSE)
strat = PS.analysis(PSA.est.PS,treatment,outcome,covardataset,bpsa = 1)
PSA.ate = mean(strat$ATE)
PSA.se = strat[["Average SE"]]
CI=freq.output(PSA.ate,PSA.se)
coverage_PSA=between(trueATE,CI[1],CI[2])
results[m,7:11]=data.frame(PSA.ate,PSA.se,CI[1],CI[2],coverage_PSA)
#cat("\n")
}
mean(results$BPSAcoverage)
mean(results$PSAcoverage)
mean(abs(results$trueATE-results$BayesATE))
mean(abs(results$trueATE-results$FreqATE))
View(results)
#save.image(file = paste0("M",M,"p",p,"_adjusted_s2_flatprior.RData"))
save.image(file = paste0("M",M,"p",p,"_unadjust_s2_flatprior.RData"))
